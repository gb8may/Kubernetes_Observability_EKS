KUBERNETES

Count of pods per cluster and namespace
Detects unusually high or low number of containers

sum by (kube_cluster_name, kube_namespace_name) (kube_pod_info)

--
Pods using less than 25% of their memory or CPU requests
Detects wasted resources in the cluster

sum by (kube_cluster_name, kube_namespace_name, kube_pod_name)(sysdig_container_cpu_cores_used) / (sum by (kube_cluster_name, kube_namespace_name, kube_pod_name)(sysdig_container_cpu_cores_used) >0) < 0.25

--
Number of containers by cluster and namespace without CPU or memory limits
Detects best effort containers to avoid undesired evictions due to high usage of resources

count by (kube_cluster_name, kube_namespace_name)((kube_pod_container_resource_limits{resource="cpu"} == 0) and (kube_pod_container_resource_limits{resource="cpu"} == 0))

--
CPU consumed by a workload
Identify total CPU for each application per namespace/cluster

sum by (kube_cluster_name, kube_namespace_name, workload_type, workload_name) (sysdig_container_cpu_cores_used)

--
CPU consumed by container
Identify total CPU for each container per namespace/cluster

sum by (kube_cluster_name, kube_namespace_name, workload_type, workload_name,container_label_io_kubernetes_container_name)(sysdig_container_cpu_cores_used)

--
Memory consumed by a workload
Identify total memory for each application per namespace/cluster

sum by (kube_cluster_name, kube_namespace_name, workload_type, workload_name) (sysdig_container_memory_used_bytes)

--
Pod restarts by namespace
A high pod restart rate usually means CrashLoopBackOff

sum by(kube_cluster_name, kube_namespace_name)(changes(kube_pod_status_ready{condition="true"}[$__interval]))

--
Top 5 memory consuming containers
Identify greedy containers using a lot of memory

topk(5,sysdig_container_memory_used_bytes)

--
Percent of the memory used by the top 5 containers vs total used by all containers
This gives an idea of the memory share in the nodes

100 * sum(topk(5,sysdig_container_memory_used_bytes)) / sum(sysdig_container_memory_used_bytes)

--
CPU overcommit
CPU limit over the capacity of the cluster

sum(sum by (kube_cluster_name)(kube_pod_container_resource_limits{resource="cpu"}) - sum by (kube_cluster_name)(kube_node_status_capacity_cpu_cores))

--
Memory overcommit
Memory limit over the capacity of the cluster

sum(sum by (kube_cluster_name)(kube_pod_container_resource_limits{resource="memory"}) - sum by (kube_cluster_name)(kube_node_status_capacity_memory_bytes))

--
Pods not ready
Pods with any kind of issue

sum by (kube_cluster_name, kube_namespace_name) (kube_pod_status_ready{condition="false"})

--
Unused requested CPU by all replicas of container
Detects wasted CPU resources broken down by workload

sum by (kube_cluster_name,kube_namespace_name,container_label_io_kubernetes_container_name)(sysdig_container_cpu_shares_count / 1024) - sum by (kube_cluster_name,kube_namespace_name,container_label_io_kubernetes_container_name)(sysdig_container_cpu_cores_used >0)

--
Unused requested memory by all replicas of container
Detects wasted memory resources down by workload

sum by (kube_cluster_name, kube_namespace_name,kube_pod_name)(kube_pod_container_resource_requests) - sum by (kube_cluster_name, kube_namespace_name,kube_pod_name)(sysdig_container_memory_used_bytes>0)

--

INFRASTRUCTURE

Identify hosts using more than 85% CPU
High CPU usage can result in a slow down of applications running on a host

sysdig_host_cpu_used_percent > 85

--
Identify hosts using more than 85% open file descriptors
Reaching the file descriptor limit will result in system instability

sysdig_host_fd_used_percent > 85

--
Identify hosts using more than 90% memory
Running out of memory will result in applications being killed and general system instability

sysdig_host_memory_used_percent > 90

--
Total bandwidth per cluster
Sum of inbound and outbound network traffic per cluster

sum by (agent_tag_cluster) (sysdig_host_net_in_bytes + sysdig_host_net_out_bytes)

--
Number of ready nodes per cluster
List number of nodes available in each cluster

sum by (kube_cluster_name)(kube_node_status_condition{condition="Ready", status="true"}==1)

--
Nodes not ready
Detects possible issues in nodes

kube_node_status_condition{condition!="Ready", status="true"} ==1

--
Nodes readiness flapping
Identify nodes flapping between ready / not ready

sum(changes(kube_node_status_condition{status="true",condition="Ready"}[15m])) by (node) > 2

--

TROUBLESHOOTING

Top processes network usage
Identify greedy processes using the most network

topk(20,sum by (kube_cluster_name,host,program_cmd_line)(sysdig_program_net_out_bytes + sysdig_program_net_in_bytes))

--
Top processes cores usage
Identify greedy processes using the most CPU cores

topk(20,sum by (kube_cluster_name,host,program_cmd_line)(sysdig_program_cpu_cores_used))

--
Top processes memory usage
Identify greedy processes using the most memory

topk(20,sum by (kube_cluster_name,host,program_cmd_line)(sysdig_program_memory_used_bytes))

--
Containers using either more than 75% of their memory or CPU limit
Identify containers close to their limit - reaching your limit results in CPU throttling or the OOM killer being invoked

sysdig_container_cpu_quota_used_percent > 75 or sysdig_container_memory_limit_used_percent > 75

--

PROMQL 101

Basic selector
It shows the time-series of a metric. Selector with label to return matching time series. Available matchers are: = (equal), != (not equal), =~(matches a regex), !~ (doesn’t match a regex). Multiple labels can be specified separated by comma

sysdig_host_cpu_used_percent{host_hostname!='foo'}

--
Offset modifier
When a query is executed, a time is provided. This defaults to now. Instant vectors return the most recent sample before this, in accordance with staleness. Range vectors return everything from the query time looking back as far as the duration. This uses the same duration syntax as range vectors

sysdig_host_cpu_used_percent offset 1d

--
Math functions
It takes in a vector and returns a vector, and generally does what you’d expect. Available math functions are: abs,ceil, exp, floor, ln, log2, log10, round, sqrt

log10(sysdig_container_memory_used_bytes)

--
Clamping
It sets a bound on the returned values. This can be useful if you sometimes get spurious values, or incorrectly implemented counters. Two bounds can be set: a lower bound (clamp_min) and an upper bound (clamp_max)

clamp_max(sysdig_host_cpu_cores_used,1)

--
Time and dates
You can break a timestamp into multiple time measurements. Available functions are: day_of_month,day_of_week, days_in_month, hour, minute,month, year

day_of_month()

--
Changes
The number of times each time series changed value

changes(kube_pod_status_ready{condition="true"}[$__interval])

--
Derivatives
This uses a least-squares regression to estimate per-second change in a time series

deriv(sysdig_host_memory_used_percent[$__interval])

--
Linear prediction
Uses a least-squares regression, and uses it to predict where the time series will be in the given amount of seconds

predict_linear(sysdig_fs_free_bytes[1h], 3600)

--
Label replace
The most complicated function in PromQL. It allows you to set a label based on a regex applied to a label. If the regex doesn’t match, the original time series is returned. It takes a vector, the new label, a replacement string, the old label and a regex for the label

label_replace(sysdig_fs_used_bytes,"a_new_label", "$1","fs_device","(.*)")

--
Label join
This joins the values of multiple labels with the given separator. It takes a vector, the new label, a separator string, and existing labels

sum by (cluster_host) (label_join(sysdig_host_cpu_used_percent{}, "cluster_host", ",", "agent_tag_cluster", "host_hostname"))

--
Sort ascending
It returns a sorted (ascendingly) vector. A descendent version exists called sort_desc. NaNs always sort to the end, so these functions aren’t simple reverses of each other

sort(sysdig_container_memory_used_bytes)

--
Sort descending
It returns a sorted (in descending order) vector. An ascending version exists called sort. NaNs always sort to the end, so these functions aren’t simple reverses of each other

sort_desc(sysdig_container_memory_used_bytes)

--
Missing values
This returns nothing if there are any time series in the vector. If there are no time series, it returns 1 with labels taken from the selector - so use this directly on selectors

absent(sysdig_host_cpu_used_percent)

--
Aggregators
They take an instant vector, and return an instant vector. Available aggregators are: sum, count, count_values, min, max, avg, stddev, stdvar, topk, bottomk, quantile. Special cases are topk and bottomk that also take a number of lines, quantile lines that takes the percentile, and count_values that needs a specified value to count

count(sysdig_host_info)

--
Aggregation excluding labels
The without modifier says to use all the labels in the output - except the ones listed. Another modifier is by, which says to only output the given labels

count without (host_hostname) (sysdig_fs_info)

--
Aggregation including labels
The by modifier says to exclude all the labels in the output - except the ones listed. Another modifier is without, which says to only exclude the given labels

count by (fs_type) (sysdig_fs_info)

--
Operators
Basic arithmetic (+ - * / % ^), comparison (== != > >= < <=), and logical (and unless or) operators as found in many programing languages, are also found here

sysdig_host_memory_used_bytes / sysdig_host_memory_total_bytes * 100
